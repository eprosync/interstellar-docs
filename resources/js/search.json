[[{"l":"Introduction","p":["Lua C++ Linux Windows","A small project because I got bored one-day..., aah jeee. I just wanted something nice and easy to read >.>","Interstellar is designed to expand & unrestrict functionality behind LuaJIT. This can negatively impact any form of security measures you place, you have been warned."]},{"l":"Usage","p":["Interstellar is designed to expand or add libraries to existing LuaJIT runtimes. There are two modes of applying to existing runtimes:","Internal - We assume you have LuaJIT part of your project thus only requiring the headers.","External - We assume you are loading into a part of a project, which will resolve functions instead.","External requires knowledge of the build of LuaJIT running on a project."]}],[{"l":"base","p":["This is an expansion to the existing Lua Base library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"assert(v: any, message?: string): any","p":["Raises an error if value of v is nil or false.","Message is optional, defaults to \"assertion failed!\".","If no error, returns the value v."]},{"l":"collectgarbage(opt: string, arg?: any): number?","p":["Responsible for controlling and retrieving information about Lua's garbage collector."]},{"l":"error(message: string, level?: number)","p":["Raises an error with the supplied message.","If a level is supplied the error points to the current function (level 1 or nil), the parent function (level 2) and so on."]},{"l":"gcinfo()","p":["Returns Kb of dynamic memory in use.","Raises an error with the supplied message.","If a level is supplied the error points to the current function (level 1 or nil), the parent function (level 2) and so on."]},{"l":"getfenv(f: number | function): table","p":["Returns the current environment used by the nominated function f.","f can be a function or a number representing the stack level, where 1 is the currently running function, 2 is its parent and so on."]},{"l":"getmetatable(obj: table | function | userdata): table?","p":["Returns metatable for the nominated object."]},{"l":"ipairs(t: table): function, table, number","p":["Returns an iterator function, the table t, and 0, for use in the generic \"for\" loop."]},{"l":"next(t: table, i?: index): any, any","p":["Traverses all entries in a table.","Returns the next index, value pair.","If index is nil (the default), returns the first pair.","When called with the last index of the table (or with an index of nil for an empty table), returns nil."]},{"l":"pairs(t: table): function, table, any?","p":["Returns the 'next' function, the table t, and nil, for use in a for loop."]},{"l":"pcall(f: function, ...: any): boolean, string | any, ...any","p":["Calls function f with the supplied arguments in protected mode.","Catches errors and returns."]},{"l":"print(...: any)","p":["Prints its arguments to stdout"]},{"l":"rawequal(v1: any, v2: any): boolean","p":["Returns a boolean depending on v1 == v2 without invoking any table metamethods."]},{"l":"rawget(t: table, i: any): any","p":["Gets the real value of table [index] without invoking metamethods."]},{"l":"rawset(t: table, i: any, v: any)","p":["Sets the value of table [index] to value, without invoking metamethods."]},{"l":"select(index: string | number, ...: any): ...any","p":["If index is a number, returns all items in the list from that number onwards.","Otherwise index must be the string \"#\", in which case it returns the number of items in the list."]},{"l":"setfenv(f: number | userdata | thread | function, env: table)","p":["Sets the current environment to be used by f, which can be a function, userdata, thread or stack level.","Level 1 is the current function.","Level 0 is the global environment of the current thread.","The \"env\" argument is a table, which effectively becomes the \"root\" for the environment."]},{"l":"setmetatable(t: table, metatable: table): table","p":["Sets the metatable for the nominated table.","If metatable is nil, removes the metatable.","If the original metatable has a \"__ metatable\" entry an error is raised."]},{"l":"tonumber(v: number | string, base?: number = 10): number","p":["Converts n to a number using the optional base (default 10), base can be from 2 to 36.","For bases > 10 the letters a-z (not case sensitive) represent the digits. (eg. F is 15).","For decimal numbers you can supply fractions and exponents. Others should be unsigned.","Returns nil if the number cannot be converted."]},{"l":"tostring(v: any): string","p":["Converts its argument to a string in a reasonable format.","If a __ tostring metatable field is found, that is used for the conversion."]},{"l":"type(v: any): string","p":["Returns a string, which is the type."]},{"l":"unpack(t: table): ...any","p":["Returns all elements from the given list (table) as individual values."]},{"l":"xpcall(f: function, err: function): boolean, any, ...any","p":["Calls function f with err as the custom error handler.","If an error occurs in f it is caught and the error-handler 'err' is called, then xpcall returns false, and whatever the error handler returned.","If there is no error in f, then xpcall returns true, followed by the function results from f."]}],[{"l":"bit","p":["This is an expansion to the existing Lua Bit library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"bit.arshift(v: number, count: number): number","p":["Returns the arithmetically shifted value."]},{"l":"bit.band(...: number): number","p":["Performs the bitwise and for all values specified."]},{"l":"bit.bnot(v: number): number","p":["Returns the bitwise not of the value."]},{"l":"bit.bor(...: number): number","p":["Returns the bitwise OR of all values specified."]},{"l":"bit.bswap(v: number): number","p":["Swaps the byte order."]},{"l":"bit.bxor(v: number, other?: number): number","p":["Returns the bitwise xor of all values specified."]},{"l":"bit.lshift(v: number, count: number): number","p":["Returns the left shifted value."]},{"l":"bit.rol(v: number, count: number): number","p":["Returns the left rotated value."]},{"l":"bit.ror(v: number, count: number): number","p":["Returns the right rotated value."]},{"l":"bit.rshift(v: number, count: number): number","p":["Returns the right shifted value."]},{"l":"bit.tobit(v: number): number","p":["Normalizes the specified value and clamps it in the range of a signed 32bit integer."]},{"l":"bit.tohex(v: number, chars: number = 8): string","p":["Returns the hexadecimal representation of the number with the specified number of characters."]}],[{"l":"buffer","p":["A universal handler for dealing with streams, buffer data and large computable data. This can be used to perform arithmetic, bitwise, stacks or even consumers. Buffers can be held in reference in C to allow for continueous streams."]},{"l":"Functions"},{"l":"buffer.new(data?: number | string | buffer): buffer","p":["Creates a new buffer class.","Passing another buffer through this just clones it."]},{"l":"buffer.number(data: number): buffer","p":["Strict number conversion to a buffer."]},{"l":"buffer.string(data: string): buffer","p":["Strict string conversion to a buffer."]},{"l":"buffer.hex(data: string): buffer","p":["Converts a hex-style string to a buffer."]},{"l":"buffer.bytes(data: number[]): buffer","p":["Converts an array of 8-bit numbers to a buffer.","8-bit numbers are represented as 0 - 255, anything above will get ignored due to dataloss."]},{"l":"buffer.binary(data: number[] | boolean[]): buffer","p":["Converts an array of single-bit numbers or booleans to a buffer","Obviously if you pass anything higher than a \"1\" it will get ignored."]},{"l":"Basics"},{"l":"buffer:clone(): buffer","p":["Makes a clone of the current buffer.","This is similar to buffer.new, in a sense you can pass a number and get a buffer from it."]},{"l":"buffer:size(): number","p":["Gets the allocated size of the buffer.","Size is relative to how much data the buffer must use to keep relevant data."]},{"l":"buffer:peek(idx: number): number","p":["Gets a byte out of the buffer without deleting it."]},{"l":"buffer:insert(idx: number, value: number...)","p":["Inserts bytes into the buffer."]},{"l":"buffer:push(value: number...)","p":["Pushes bytes into the buffer at the start."]},{"l":"buffer:push_back(value: number...)","p":["Pushes bytes into the buffer at the end."]},{"l":"buffer:remove(idx: number): number","p":["Removes and returns a byte from the buffer at an index."]},{"l":"buffer:shift(): number","p":["Removes and returns a byte from the buffer from the front."]},{"l":"buffer:pop(): number","p":["Removes and returns a byte from the buffer from the back."]},{"l":"buffer:substitute(beginning: number, ending?: number): buffer","p":["Gets a subset of the buffer based on the start and end positions."]},{"l":"buffer:concat(other: number | string | buffer): buffer","p":["Concats two buffers or data together.","Basically \"hello \" .. \"world\" in buffers would make \"hello world\"."]},{"l":"Consumers"},{"l":"buffer:bytes(size: number): buffer","p":["Gets a subset of the buffer while consuming the size requested."]},{"l":"buffer:uint8(): number","p":["Gets & consumes an unsigned integer of size 8"]},{"l":"buffer:uint8(data: number)","p":["Pushes back an unsigned integer of size 8"]},{"i":"bufferuint8-number-1","l":"buffer:uint8(): number","p":["Gets & consumes an integer of size 8"]},{"l":"buffer:int8(data: number)","p":["Pushes back an integer of size 8"]},{"l":"buffer:uint16(): number","p":["Gets & consumes an unsigned integer of size 16"]},{"l":"buffer:uint16(data: number)","p":["Pushes back an unsigned integer of size 16"]},{"i":"bufferuint8-number-2","l":"buffer:uint8(): number","p":["Gets & consumes an integer of size 16"]},{"l":"buffer:int16(data: number)","p":["Pushes back an integer of size 16"]},{"l":"buffer:uint32(): number","p":["Gets & consumes an unsigned integer of size 32"]},{"l":"buffer:uint32(data: number)","p":["Pushes back an unsigned integer of size 32"]},{"i":"bufferuint32-number-1","l":"buffer:uint32(): number","p":["Gets & consumes an integer of size 32"]},{"l":"buffer:int32(data: number)","p":["Pushes back an integer of size 32"]},{"l":"buffer:uint64(): number","p":["Gets & consumes an unsigned integer of size 64"]},{"l":"buffer:uint64(data: number)","p":["Pushes back an unsigned integer of size 64"]},{"i":"bufferuint64-number-1","l":"buffer:uint64(): number","p":["Gets & consumes an integer of size 64"]},{"l":"buffer:int64(data: number)","p":["Pushes back an integer of size 64"]},{"l":"buffer:uleb128(): number","p":["Gets & consumes an unsigned integer of size 128","This is a form of compression for large numbers"]},{"l":"buffer:uleb128(data: number)","p":["Pushes back an unsigned integer of size 128","This is a form of compression for large numbers"]},{"l":"Comparators"},{"l":"buffer:equal(other: number | string | buffer): boolean","p":["If a value or buffer is equal"]},{"l":"buffer:notequal(other: number | string | buffer): boolean","p":["If a value or buffer is not equal"]},{"l":"buffer:lessthan(other: number | string | buffer): boolean","p":["If a value or buffer is less than"]},{"l":"buffer:greaterthan(other: number | string | buffer): boolean","p":["If a value or buffer is greater than"]},{"l":"Arithmetic"},{"l":"buffer:add(other: number | string | buffer): buffer","p":["Performs an arithmetic addition."]},{"l":"buffer:sub(other: number | string | buffer): buffer","p":["Performs an arithmetic subtraction."]},{"l":"buffer:mul(other: number | string | buffer): buffer","p":["Performs an arithmetic multiplication."]},{"l":"buffer:div(other: number | string | buffer): buffer","p":["Performs an arithmetic division."]},{"l":"buffer:pow(other: number | string | buffer): buffer","p":["Performs an arithmetic powers.","Do note that this can be very intensive and memory consuming."]},{"l":"Bitwise"},{"l":"buffer:bnot(): buffer","p":["Performs a bitwise not operation."]},{"l":"buffer:bor(other: number | string | buffer): buffer","p":["Performs a bitwise or operation."]},{"l":"buffer:band(other: number | string | buffer): buffer","p":["Performs a bitwise and operation."]},{"l":"buffer:bxor(other: number | string | buffer): buffer","p":["Performs a bitwise exclusive or operation."]},{"l":"buffer:blshift(other: number | string | buffer): buffer","p":["Performs a bitwise left-shift operation."]},{"l":"buffer:brshift(other: number | string | buffer): buffer","p":["Performs a bitwise right-shift operation."]},{"l":"buffer:blroll(other: number | string | buffer): buffer","p":["Performs a bitwise left-roll operation."]},{"l":"buffer:brroll(other: number | string | buffer): buffer","p":["Performs a bitwise right-roll operation."]},{"l":"Conversions"},{"l":"buffer:tonumber(): number","p":["Converts the buffer to a number representation.","Lua handles numbers using doubles so you may get some precision loss or missing data."]},{"l":"buffer:tostring(): string","p":["Converts the buffer to a string representation."]},{"l":"buffer:tohex(): string","p":["Converts the buffer to a hex-string representation."]},{"l":"buffer:totable(): number[]","p":["Converts the buffer to an array of 8-bits.","The buffer internally is represented by this."]},{"l":"buffer:tobinary(): number[]","p":["Converts the buffer to an array of bits.","Represented as 1's and 0's, not booleans."]},{"l":"Meta Operators","p":["Support for __* operations."]},{"l":"buffer:operator+(other: buffer): buffer","p":["Adds two buffers together through arithmetrics"]},{"l":"buffer:operator-(other: buffer): buffer","p":["Subtracts two buffers together through arithmetrics"]},{"i":"bufferoperatorother-buffer-buffer-1","l":"buffer:operator*(other: buffer): buffer","p":["Multiplies two buffers together through arithmetrics"]},{"i":"bufferoperatorother-buffer-buffer-2","l":"buffer:operator/(other: buffer): buffer","p":["Divides two buffers together through arithmetrics"]},{"i":"bufferoperatorother-buffer-buffer-3","l":"buffer:operator^(other: buffer): buffer","p":["Pow's two buffers together through arithmetrics"]},{"l":"buffer:operator..(other: number | string | buffer): buffer","p":["Concats two buffers together just like buffer:concat"]},{"l":"buffer:operator==(other: buffer): boolean","p":["Compares two buffers together just like buffer:equal"]},{"i":"bufferoperatorother-buffer-boolean-1","l":"buffer:operator(other: buffer): boolean","p":["Compares two buffers together just like buffer:lessthan and buffer:greaterthan"]}],[{"l":"coroutine","p":["This is an expansion to the existing Lua Coroutine library.","Coroutines are a very powerful way of splitting execution of a function up until some event occurs (for example, a timer fires, or input arrives). The function chooses when to \"yield\" execution.","The yield / resume sequence allows variables to be passed back and forward between the thread and the caller. For example the thread can yield with an argument which tells the caller why it yielded, and the caller can resume with an argument telling the thread why it was resumed.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"coroutine.create(f: function): thread","p":["Creates a thread consisting of the body f."]},{"l":"coroutine.resume(t: thread, ...: any): boolean, ...any","p":["Start or resume a thread created by coroutine.create. Any values supplied after the thread are returned as results from the coroutine.yield inside the thread.","If this is the first call for this thread, the values are supplied to the function itself."]},{"l":"coroutine.running(): thread","p":["Returns the running coroutine, or no value when called by the main thread."]},{"l":"coroutine.status(): string","p":["Returns a string indicating the status of the thread.","Raises an error if the argument is not a thread."]},{"l":"coroutine.wrap(f: function): function","p":["Creates a thread with body f, and then returns a function that can be used to resume the thread."]},{"l":"coroutine.yield(...: any): ...any","p":["Yields execution back to the caller, effectively creating co-operative multi-tasking, values supplied to yield are returned to coroutine.resume.","The coroutine cannot be running a C function, a metamethod, or an iterator."]}],[{"l":"debug","p":["This is an expansion to the existing Lua debug library. This allows you to create many ways of accessing data that would be otherwise impossible. As well as providing security features for safety of instrusions to lua-based APIs not from the Interstellar.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"debug.getfenv(obj: function | number): table?","p":["Returns the environment of object obj.","This differs a bit from the base function getfenv, which takes a function or a level number, and converts the level number into a function."]},{"l":"debug.gethook(thread: thread | function | number): function, number, number","p":["Returns the current hook settings as three values: Hook Function, Mask, Count"]},{"l":"debug.getinfo(thread: thread | function | number, field?: string, what?: function): table","p":["Returns a table with information about a function or stack level"]},{"l":"debug.getlocal(level: number | function, local: number): string, any","p":["Returns the name and value of the local variable with the index 'local' of the function at 'level' on the stack."]},{"l":"debug.getmetatable(obj: proto | function | table | userdata): table?","p":["Returns the metatable of the given object or nil if it does not have a metatable."]},{"l":"debug.getregistry(): table","p":["Returns the registry table, which is a special table used by C functions to store information it wants to keep isolated from Lua functions.","This can act as permanent storage for variables to be retreived later on."]},{"l":"debug.getupvalue(level: number | function, upvalue: number): string, any","p":["Similar to debug.getlocal, returns the names and values of the upvalues for the nominated function."]},{"l":"debug.setfenv(obj: function | number, tbl: table): any","p":["Sets the environment of the given object to the given table, returns the object."]},{"l":"debug.setlocal(obj: function | number, local: number, value: any)","p":["Sets the value of the local variable with the index 'local' of the function at 'level' on the stack."]},{"l":"debug.sethook(thread: thread | function | number, f?: function, mask?: number, count?: number)","p":["Sets the function f as a hook to be called when the \"mask\" condition is satisfied.","If count is non-zero, it is called after every \"count\" instructions.","The thread argument is optional and defaults to the current thread.","If called without arguments, turns off the hook.","The function f is called with its first parameter being a string, which can be one of: call, return, tail return, line, count"]},{"l":"debug.setmetatable(obj: proto | function | table | userdata, tbl: table): any","p":["Sets the metatable for the given object to the given table (which can be nil).","Bypasses the check for the \"__ metatable\" entry.","Returns the object."]},{"l":"debug.setupvalue(level: number | function, upvalue: number, value: number)","p":["Similar to debug.setlocal, sets the values of the upvalue for the nominated function."]},{"l":"debug.traceback(thread?: number | function | string, message?: string, level?: number)","p":["Returns a string with a traceback of the stack call.","An optional message string is prepended to the beginning of the traceback message."]},{"l":"Extension"},{"l":"debug.registry(): table","p":["Gets the true debug registry table.","This table is used to keep permanent objects, preventing GC from removing them."]},{"l":"debug.global(): table","p":["Gets the true global table."]},{"l":"debug.env(): table","p":["Gets the current stack's environment."]},{"l":"debug.clone(value: function | proto | userdata): function | proto | userdata","p":["Copys a value in memory, creating a completely new value but with the same characteristics."]},{"l":"debug.replace(target: function | proto | userdata, value: function | proto | userdata)","p":["Replaces a value by reference in memory, effectively replacing all occurences of it."]},{"l":"debug.newcclosure(func: function): function","p":["Creates a new cfunction closure which is untraceable."]},{"l":"debug.getgc(iterator?: boolean): (table | function | proto | userdata)[] | function","p":["Gets the garbage collector table.","This has iterator functionality in foreach-loops.","Do note this contains every value in existance."]},{"l":"debug.topointer(data: any, str: boolean): string | number","p":["Converts a datatype into it's absolute pointer location.","Output looks like this: 0xd8ad9caa or 3635244450"]},{"l":"debug.frompointer(ptr: number): function | table | proto | userdata","p":["Scans memory to find the pointer association."]},{"l":"debug.toproto(f: function): proto","p":["Converts an function to a prototype object"]},{"l":"debug.fromproto(p: proto): function","p":["Converts an prototype into a function handle","Do note this creates a completely new function"]},{"l":"debug.getprotos(f: function | proto): proto[]","p":["Gets a list of subset protos under a function.","Think of these as function() end inside of the current function."]},{"l":"debug.dump(f: function | proto): string","p":["Converts a function or proto into it's bytecode representation.","This is done with debug information available."]},{"l":"debug.tosignature(f: function | proto): string","p":["Creates a signature based on several factors.","Each options character represents a different form of signature.","max indicates how much scanning each options should introduce, this is to limit the size of the output string.","^ (we will make it semi-automatic later on by unique scanning)"]},{"l":"debug.fromsignature(sig: string): function | proto | undefined","p":["Attempts to look for a certain function or proto based on the given signature.","Depending on parameters when you first created the signature, substle changes in a function can invalidate a signature entirely."]},{"l":"debug.tscan(input: table, comparator: function(value: table): boolean): table?, string[]?","p":["Based on the comparator, attempts to scan for another table thats associated.","This works to counter-act attempts to hide tables via a proxy or other means.","This returns a signature array for you to use debug.tresolve(input: table, string[]): table? instead."]},{"l":"debug.tresolve(input: table, string[]): table?","p":["Like debug.tscan(input: table, comparator: function(value: table): boolean): table?, string[]?","However, instead of \"scanning\" it uses the already generated signature array to find the value.","This is extremely efficient compared to re-scanning for the designated value via a comparator."]},{"l":"debug.getconstant(f: function | proto, index: number): any","p":["Gets a function's constant by their index"]},{"l":"debug.getconstants(f: function | proto): {[index: string]: any}","p":["Gets all constants from a function or proto"]},{"l":"debug.setconstant(f: function | proto, index: number, value: any): boolean","p":["Sets a constant in a function or proto at an index","Returns a boolean on if it was able to do so"]},{"l":"debug.iscfunction(f: function): boolean","p":["Checks if the provided function is made by \"C\""]},{"l":"debug.islfunction(f: function): boolean","p":["Checks if the provided function is made by \"Lua\""]},{"l":"debug.setbuiltin(func: cfunction, ffid: number)","p":["Changes a cfunction to be a Fast Function with an ID.","This will make them appear as builtin: xx","Use newcclosure if you plan to make a detour with this."]},{"l":"debug.getbuiltin(func: cfunction): number","p":["Gets the ffid number of a cfunction."]},{"l":"debug.getupvalues(func: function): {[index: string]: any}","p":["Gets a list of upvalues and that a function has."]},{"l":"debug.validlevel(level: number): boolean","p":["Checks if the level exists and is valid."]},{"l":"debug.getcallstack(): function[]","p":["Gets a list of functions that have been used at the current execution."]},{"l":"debug.getbase(level: number): function?","p":["Gets the current executing function at a level."]},{"l":"debug.typestack(count?: number): string","p":["Fetches a list of the current stack memory.","This is used to debug and print out what it looks like."]},{"l":"debug.hook.sync(f: function, callback: function): function","p":["Creates a hook towards a target Lua/C function."]},{"l":"debug.hook.async(f: cfunction, callback: function): function","p":["Creates a hook towards a target C function.","Unlike sync hooks, this cannot be found due to it being a low-level hook.","This runs callbacks in a different stack environment preventing stack tracing."]},{"l":"debug.hook.restore(f: function): boolean","p":["Attempts to restore a Lua/C function to its original state."]},{"l":"debug.hook.is(f: function): boolean","p":["Checks if a Lua/C function has been hooked."]},{"l":"debug.hook.inside(): boolean","p":["If we are currently executing inside an active hook."]},{"l":"debug.hook.original(f: function): function?","p":["Fetches the original Lua/C function that has been hooked."]},{"l":"debug.hook.active(f: function): boolean","p":["Checks if a Lua/C function is actively being hooked."]},{"l":"debug.hook.disable(f: function): boolean","p":["Disables an on-going hook from running, effectively making it the original temporarily."]},{"l":"debug.hook.enable(f: function): boolean","p":["Enables an on-going hook, allowing callbacks to be ran."]},{"l":"CAPI"},{"l":"L:registry()","p":["Gets the true debug registry table, pushing it onto the stack.","This table is used to keep permanent objects, preventing GC from removing them."]},{"l":"L:global()","p":["Gets the true global table, pushing it onto the stack."]},{"l":"L:env()","p":["Gets the current stack's environment, pushing it onto the stack."]},{"l":"L:getgc()","p":["Gets the garbage collector table, pushing it onto the stack.","Do note this contains every value in existance."]},{"l":"L:newcclosure(index: number)","p":["Creates a new cfunction closure which is untraceable."]},{"l":"L:clone(index: number)","p":["Copys a value in memory, creating a completely new value but with the same characteristics."]},{"l":"L:replace(target: number, value: number)","p":["Replaces a value by reference in memory, effectively replacing all occurences of it."]},{"l":"L:topointer(index: number, str: boolean): string | number","p":["Converts a datatype into it's absolute pointer location.","Output looks like this: 0xd8ad9caa or 3635244450"]},{"l":"L:frompointer(ptr: number)","p":["Scans memory to find the pointer association, pushing it onto the stack."]}],[{"l":"fs","p":["File system access with restrictions & canonical resolution. This one allows the use of \"..\", without breaching the workspace."]},{"l":"Functions"},{"l":"fs.separator: string","p":["The separator character responsible for the current filesystem"]},{"l":"fs.read(path: string, async?: function): string?","p":["Reads a file from a given path","Runs in async if a function is provided"]},{"l":"fs.write(path: string, data: string | buffer, async?: function | boolean)","p":["Writes to a file provided by the path","Runs in async if passing a function or boolean","Function callback acts as trigger from completion"]},{"l":"fs.append(path: string, data: string | buffer, async?: function | boolean)","p":["Appends data onto the specified file","Runs in async if passing a function or boolean","Function callback acts as trigger from completion"]},{"l":"fs.isfile(path: string): boolean","p":["Checks if a filesystem object is a file"]},{"l":"fs.isfolder(path: string): boolean","p":["Checks if a filesystem object is a folder"]},{"l":"fs.readable(path: string): boolean","p":["Checks if a filesystem object is readable"]},{"l":"fs.writeable(path: string): boolean","p":["Checks if a filesystem object is writeable"]},{"l":"fs.scan(path: string): string[]","p":["Lists files in the specified path"]},{"l":"fs.mkdir(path: string)","p":["Creates a folder in the specified path","This is recursive, allowing it to generate multiple folders"]},{"l":"fs.rmdir(path: string)","p":["Deletes a folder from the specified path"]},{"l":"fs.rmfile(path: string)","p":["Deletes a file from the specified path"]},{"l":"fs.rm(path: string)","p":["Deletes any file or folder from the specified path"]},{"l":"fs.mv(from: string, to: string): boolean","p":["Moves any file or folder to a new location","This will overwrite files"]},{"l":"fs.cp(from: string, to: string): boolean","p":["Copies any file or folder to a new location","This will overwrite files"]},{"l":"fs.forward(path: string): string","p":["Changes all \"\\\" separators to \"/\""]},{"l":"fs.backward(path: string): string","p":["Changes all \"/\" separators to \"\\\""]},{"l":"fs.join(a: string, b: string): string","p":["Joins two paths together"]},{"l":"fs.extname(path: string, replace?: string): string","p":["Gets the extension name of a path","If provided a replacement, will return the replaced path's extension"]},{"l":"fs.filename(path: string, replace?: string): string","p":["Gets the file name of a path","If provided a replacement, will return the replaced path's file"]},{"l":"fs.dirname(path: string, replace?: string): string","p":["Gets the directory name of a path","If provided a replacement, will return the replaced path's directory"]},{"l":"fs.sanitize(path: string): string","p":["Removes any oddities in the path, replacing them with \"_\" instead."]},{"l":"fs.canonical(path: string): string","p":["Resolves a path to its absolute form.","This converts special FS directives such as \"..\" to absolute path.","Useful for many different situations, like isolation."]},{"l":"fs.within(root: string, path: string): boolean","p":["Checks if a path is within a root path.","This works great with functions like fs.canonical to determine isolation."]}],[{"l":"iot","p":["IOT is a communication system to the internet. You can use this to create secure connections to external backends you create."]},{"l":"Enums"},{"l":"iot.method: {[index: string]: string}","p":["Contains a list of method procedures for HTTP/HTTPS"]},{"l":"iot.status: {[index: string | number]: string | number}","p":["Contains a list of status codes for HTTP/HTTPS"]},{"l":"iot.opcode: {[index: string | number]: string | number}","p":["Contains a list of opcode procedures for sockets"]},{"l":"iot.closure: {[index: string | number]: string | number}","p":["Contains a list of closure procedures for sockets","These are usually needed when dealing with iot.closure.close cases"]},{"l":"Functions"},{"l":"iot.http(url: string, callback?: function(response: http_response), options?: http_options)","p":["Makes an HTTP/HTTPS request to an address or domain.","This function is asynchronous, meaning this will not \"freeze\" Lua.","The interface types http_options& http_response can be seen here:"]},{"l":"iot.stream(url: string, callback?: function(response: http_response), options?: http_options)","p":["Similar to iot.http except allows multiple returns from segments of encoded chunks.","When receiving chunks, all responses will have a 100 status code for continuing.","Once finished, the status code will either be 200 or a different value if it errored.","Returning false inside the callback will cancel the stream."]},{"l":"iot.socket(url: string, options?: socket_options): socket_class","p":["Creates a socket object which is connected to an address or domain.","Upon creation, the socket isn't activated until you invoke it to do so.","Sockets work by reference, so if there is no-longer a use in lua, it will destroy itself."]},{"l":"iot.serve(port: number): serve_class","p":["Creates an HTTP server for requests, similar to express/deno.","Do note that the server doesn't actually start until you invoke serve:start()","Unlike client sockets, if the object gets GC'ed, it won't cleanup the callbacks or invoke a destructor.","If you \"lose\" the handle object, you can retrieve it back by simply calling the function again and its exact port number."]},{"l":"Serve","p":["These are interface & function definitions for how we handle serve_class. All callbacks use these interfaces for HTTP IO."]},{"l":"serve.request"},{"l":"serve.response","p":["This is the accepted returns for the responses. If there is incorrect values it will default to its original value defined in the interface. This has higher precedence than the funtional version."]},{"l":"serve.response.functional","p":["Serve's response also has a functional version which doesn't require a return. You can call these multiple times allow you to override previous values. However this has lower precedence to serve.response returns."]},{"l":"res:status(state: number)","p":["Sets the response status number","If this isn't set it will default to 501"]},{"l":"res:body(data: string)","p":["Sets the response body"]},{"l":"res:header(key: string, value: string)","p":["Adds a header to the response"]},{"l":"res:headers(headers: {[index: string]: string})","p":["Sets the headers in the response"]},{"l":"serve:start(): boolean","p":["Attempts to allocate a port for HTTP connections.","If this fails it will return false.","Usually a failure indicates a port is already in-use."]},{"l":"serve:stop()","p":["De-allocates and stops serving under the allocated port.","This doesn't actually destroy the object."]},{"l":"serve:active(): boolean","p":["Checks if the current serve is active on its port."]},{"l":"serve:port(): number","p":["Gets the current port the serve is on."]},{"l":"serve:handlers(): {method: string, path: string, callback: function}[]","p":["Gets all handlers associated with the serve."]},{"l":"serve:sockets(path: string): serve_socket[]","p":["Gets all sockets associated with the serve."]},{"l":"serve:upgrade(): serve_socket","p":["Upgrades a connection into a socket.","Must be used inside of a HTTP request."]},{"l":"serve:socket(path: string, callback: function(connection: serve_socket, opcode: number, data: string | number, extra: string))","p":["Adds a callback for a certain path for socket-based messages.","Do note that the path must be the same to the socket you upgraded in.","Opcodes can be seen under iot.opcode"]},{"l":"serve:any(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Any is a form of method that allows all types of methods to be seen in callback under the path.","You can check the method by seeing req.method","If you set the path to ANY it will also act as a any filter, allowing you to process paths individually.","Do note this is first-order making it called first before any other methods"]},{"l":"serve:get(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"GET\" requests","The GET method requests a representation of the specified resource.","Requests using GET should only retrieve data and should not contain a request content."]},{"l":"serve:post(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"POST\" requests","The HEAD method asks for a response identical to a GET request, but without a response body."]},{"l":"serve:head(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"HEAD\" requests","The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server."]},{"l":"serve:put(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"PUT\" requests","The PUT method replaces all current representations of the target resource with the request content."]},{"l":"serve:delete(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"DELETE\" requests","The DELETE method deletes the specified resource."]},{"l":"serve:options(path: string, callback?: function(req: serve.request, res: serve.response.functional): serve.response?)","p":["By inputing nothing as the callback (nil), will deleted any callbacks under the path.","Adds a callback for a certain path under \"OPTIONS\" requests","The OPTIONS method describes the communication options for the target resource."]},{"l":"Serve Socket","p":["These are interface & function definitions for how we handle serve_socket"]},{"l":"serve_socket:id(): string","p":["Gets the socket's unique ID.","Useful if you need to manually track them."]},{"l":"serve_socket:disconnect(code?: string | number, reason?: string)","p":["Forces a socket to disconnect.","By providing a string in the code parameter, it will become a reason with normal closure."]},{"l":"serve_socket:text(payload: string)","p":["Sends a text-based payload."]},{"l":"serve_socket:binary(payload: string)","p":["Sends a binary-based payload."]},{"l":"serve_socket:ping(payload?: string)","p":["Sends a ping payload, typically used to keep connections alive."]},{"l":"serve_socket:pong(payload?: string)","p":["Sends a pong payload, typically used to keep connections alive."]},{"l":"Socket","p":["These are interface & function definitions for how we handle socket_class"]},{"i":"functions-1","l":"Functions"},{"l":"socket:connect()","p":["Attempt to connect the socket to the constructed URL from creation."]},{"l":"socket:disconnect(reason?: string)","p":["Disconnects from a socket server with a message if needed."]},{"l":"socket:text(payload: string)","p":["Send a payload message to the socket server."]},{"l":"socket:utf8(payload: string)","p":["Send a payload message to the socket server in UTF8 format."]},{"l":"socket:binary(payload: string)","p":["Send a payload message to the socket server in binary format."]},{"l":"socket:close(reason?: string)","p":["Closes the socket connection, this usually also sends a message.","If you want to re-open the connection, simply run socket.connect()"]},{"l":"socket:ping(reason?: string)","p":["Sends a ping payload to the socket server."]},{"l":"socket:get_url(): string","p":["Gets the current full connection URL."]},{"l":"socket:get_host(): string","p":["Gets the current host from the URL."]},{"l":"socket:get_port(): string","p":["Gets the current port from the URL."]},{"l":"socket:get_path(): string","p":["Gets the current path from the URL."]},{"l":"socket:headers_add(key: string, value: string)","p":["Adds a header to the list of headers to be sent on connection."]},{"l":"socket:headers_remove(key: string)","p":["Removes a header from the list of headers to be sent on connection."]},{"l":"socket:headers_get(key: string): string?","p":["Gets a header by the key-name."]},{"l":"socket:headers_all(key: string): {[index: string]: string}","p":["Gets a list of all headers applied."]},{"l":"socket:is_open(): boolean","p":["If the socket is currently connected."]},{"l":"socket:is_connecting(): boolean","p":["If the socket is currently connecting."]},{"l":"socket:is_closing(): boolean","p":["If the socket is currently closing."]},{"l":"socket:is_closed(): boolean","p":["If the socket is currently closed."]},{"l":"socket:is_tls(): boolean","p":["If the socket is using TLS as it's connection layer."]},{"l":"Events","p":["This internally uses the Signal library for C++ communication. These can be accessed for example by: socket_class.add(...) Signal"]},{"l":"open()","p":["Called when the socket engine has made a successful connection."]},{"l":"error(code: number, reason: string)","p":["Called if there was a connection failure."]},{"l":"close(status: number, reason: string)","p":["Called when the connection closes, this can contain an error reason."]},{"l":"message(payload: string)","p":["Called when a message has been received."]},{"l":"ping(reason: string)","p":["Called when the socket server sent a ping.","This can be used as an \"isalive\" status refresh.","However this is managed internally by interstellar."]},{"l":"pong(reason: string)","p":["Called when the socket server sent a pong.","This can be used as an \"isalive\" status refresh."]}],[{"l":"lxz","p":["LXZ is a library with an amalgamation of several compression libraries, including LZMA, ZLIB, ZSTD and more. You can view more about them on their github: bxzstr Github","Some sections here are being converted to use buffers instead of string representations."]},{"l":"Functions"},{"l":"lxz.encode.z(input: string, async?: function(output: string)): string?","p":["Compresses the input string using ZLIB compression."]},{"l":"lxz.encode.zstd(input: string, async?: function(output: string)): string?","p":["Compresses the input string using Zstandard (ZSTD) compression."]},{"l":"lxz.encode.bz2(input: string, async?: function(output: string)): string?","p":["Compresses the input string using Bzip2 (BZ2) compression."]},{"l":"lxz.encode.lzma(input: string, async?: function(output: string)): string?","p":["Compresses the input string using LZMA (Lempel-Ziv-Markov chain algorithm)."]},{"l":"lxz.decode.z(input: string, async?: function(output: string)): string?","p":["Decompresses a ZLIB-compressed string."]},{"l":"lxz.decode.zstd(input: string, async?: function(output: string)): string?","p":["Decompresses a Zstandard (ZSTD) compressed string."]},{"l":"lxz.decode.bz2(input: string, async?: function(output: string)): string?","p":["Decompresses a Bzip2 (BZ2) compressed string."]},{"l":"lxz.decode.lzma(input: string, async?: function(output: string)): string?","p":["Decompresses an LZMA-compressed string."]}],[{"l":"math","p":["This is an expansion to the existing Lua Math library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"math.abs(v: number): number","p":["Absolute value of v."]},{"l":"math.acos(v: number): number","p":["Arc cosine of v. (Inverse operation of math.cos (v))."]},{"l":"math.asin(v: number): number","p":["Arc sine of v. (Inverse operation of math.sin(v))."]},{"l":"math.atan(v: number): number","p":["Arc tangent of v. (Inverse operation of math.tan (v))."]},{"l":"math.atan2(v1: number, v2: number): number","p":["Arc tangent of v1/v2."]},{"l":"math.ceil(v: number): number","p":["Smallest integer >= v"]},{"l":"math.cos(v: number): number","p":["Cosine of v radians."]},{"l":"math.cosh(v: number): number","p":["Hyperbolic cosine of v radians."]},{"l":"math.deg(v: number): number","p":["Convert v from radians to degrees. Note that math.rad is the inverse operation."]},{"l":"math.exp(v: number): number","p":["Compute e to the power v. Note that math.log is the inverse operation."]},{"l":"math.floor(v: number): number","p":["Largest integer <= v"]},{"l":"math.fmod(v1: number, v2: number): number","p":["The modulus (remainder) of doing: v1 / v2"]},{"l":"math.frexp(v: number): number, number","p":["The frexp function breaks down the floating-point value (v) into a mantissa (m) and an exponent (n), such that the absolute value of m is greater than or equal to 0.5 and less than 1.0, and v = m * 2^ n."]},{"l":"math.huge: number","p":["The value HUGE_VAL, a value larger than or equal to any other numerical value.","Note that this is a number, not a function."]},{"l":"math.ldexp(m: number, n: number): number","p":["The ldexp function returns the value of m * 2^ n."]},{"l":"math.log(v: number): number","p":["Natural log of v (that is, to the base e)."]},{"l":"math.log10(v: number): number","p":["Log to the base 10 of v."]},{"l":"math.max(...: number): number","p":["The highest of one or more numbers."]},{"l":"math.min(...: number): number","p":["The lowest of one or more numbers."]},{"l":"math.modf(v: number): number, number","p":["Returns two numbers, the integral part of v and the fractional part of v"]},{"l":"math.pi: number","p":["A variable representing the value of pi (not a function)."]},{"l":"math.pow(v1: number, v2: number): number","p":["v1 raised to the power v2."]},{"l":"math.rad(v: number): number","p":["Convert v from degrees to radians."]},{"l":"math.random(n: number, u: number): number","p":["With no arguments, returns a random number in the range [0, 1]. That is, zero up to but excluding 1.","With 1 argument, returns an integer in the range [1, n]. That is from 1 up to and including n.","With 2 arguments, returns an integer in the range [n, u]. That is from n up to and including u.","Use math.randomseed(n: number) to seed the generator."]},{"l":"math.randomseed(n: number)","p":["Seeds the random number generator with an integer.","Re-seed with the same number to regenerate the same sequences by calling math.random.","Seeding with os.time () is a common technique to make random numbers different each time."]},{"l":"math.sin(v: number): number","p":["Sine of v radians."]},{"l":"math.sinh(v: number): number","p":["Hyperbolic sine of v radians."]},{"l":"math.sqrt(v: number): number","p":["Square root of v."]},{"l":"math.tan(v: number): number","p":["Tangent of v radians."]},{"l":"math.tanh(v: number): number","p":["Hyperbolic tangent of v radians."]},{"l":"Extension"},{"l":"math.roots.linear(a: number, b: number): number","p":["Solves the roots of ax + b"]},{"l":"math.roots.quadric(a: number, b: number, c: number): number, number","p":["Solves the roots of ax^2 + bx + c"]},{"l":"math.roots.cubic(a: number, b: number, c: number, d: number): number, number, number","p":["Solves the roots of ax^3 + bx^2 + cx + d"]},{"l":"math.roots.quartic(a: number, b: number, c: number, d: number, e: number): number, number, number, number","p":["Solves the roots of ax^4 + bx^3 + cx^2 + dx + e"]}],[{"l":"memory","p":["Memory is a direct access library to reading/writing into memory.","We are still working on adding features here such as built-in disassemblers & resolvers"]},{"l":"memory.module"},{"l":"memory.region"},{"l":"Functions"},{"l":"memory.address(value: number | string | function | userdata): memory.address","p":["Creates a new address class.","Using a string will attempt for format a hex-string to address.","Using cfunctions or userdata retrives their absolute location in memory."]},{"l":"memory.module(name?: string): memory.module","p":["Attempts to retreive a loaded module.","Windows are usually named .dll, while linux are .so"]},{"l":"memory.modules(): memory.module[]","p":["Lists all modules that has been loaded.","Windows are usually named .dll, while linux are .so"]},{"l":"memory.regions(): memory.region[]","p":["Lists all regions that is associated with the current process.","This basically gives you all of the virtual memory allocated to this process."]},{"l":"memory.base(addr: memory.address): memory.module?","p":["Attempts to locate the base module based on the address.","This only works if the address with within the address-space of a module."]},{"l":"memory.fetch(module: memory.module, name: string): memory.address","p":["Attempts to search for existing routines or variables that are disclosed."]},{"l":"memory.interface(module: memory.module, name: string): memory.address?","p":["Attempt to search for various interface routines & calls them."]},{"l":"memory.index(input: memory.address, index: number): memory.address?","p":["Performs a simple indexing on an address.","This equates to simply ((void**)input)[index]"]},{"l":"memory.offset(input: memory.address, offset: number): memory.address","p":["Performs a simple offset to an address","This equates to simply (void*)input + offset"]},{"l":"memory.relative(input: memory.address, offset: number, size: number): memory.address?","p":["Performs a relative instruction operation.","For windows-x64-intel this peaks into a subroutine using \"call\" opcode -> memory.relative(addr, 0x1, 0x5)"]},{"l":"memory.vtable(input: memory.address): memory.address?","p":["Performs a de-reference to a class for it's vtable.","This equates to simply *reinterpret_castvoid***(address)"]},{"l":"memory.read.bool(input: memory.address): boolean?"},{"l":"memory.aob.hex(module: memory.module, pattern: string): memory.address?","p":["Performs a hex-style signature scan on a module.","Example: \\xA0?\\xB1"]},{"l":"memory.aob.ida(module: memory.module, pattern: string): memory.address?","p":["Performs a ida-style signature scan on a module.","Example: A0 ? B1"]},{"i":"memoryreadboolinput-memoryaddress-boolean-1","l":"memory.read.bool(input: memory.address): boolean?","p":["Attempts to read a boolean value.","Typically the size of a boolean is defined as 1 bit.","However some systems differ claiming 1 byte or 8 bits."]},{"l":"memory.read.char(input: memory.address): number?","p":["Attempts to read a char value.","Size: 1 Byte - 8 Bits"]},{"l":"memory.read.uchar(input: memory.address): number?","p":["Attempts to read a unsigned char value.","Size: 1 Byte - 8 Bits"]},{"l":"memory.read.short(input: memory.address): number?","p":["Attempts to read a short value.","Size: 2 Bytes - 16 Bits"]},{"l":"memory.read.ushort(input: memory.address): number?","p":["Attempts to read a unsigned short value.","Size: 2 Bytes - 16 Bits"]},{"l":"memory.read.int(input: memory.address): number?","p":["Attempts to read a int value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.read.uint(input: memory.address): number?","p":["Attempts to read a unsigned int value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.read.long(input: memory.address): number?","p":["Attempts to read a long value.","Size: 4 Bytes - 32 Bits (Win) | 8 Bytes - 64 Bits (Linux)"]},{"l":"memory.read.ulong(input: memory.address): number?","p":["Attempts to read a unsigned long value.","Size: 4 Bytes - 32 Bits (Win) | 8 Bytes - 64 Bits (Linux)"]},{"l":"memory.read.float(input: memory.address): number?","p":["Attempts to read a float value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.read.double(input: memory.address): number?","p":["Attempts to read a double value.","Size: 8 Bytes - 64 Bits"]},{"l":"memory.read.sequence(input: memory.address, size: number): string","p":["Attempts to read a sequence of bytes.","Example returns: A1 B2 C3"]},{"l":"memory.read.address(input: memory.address): memory.address?","p":["Attempts to read a void* value."]},{"l":"memory.write.bool(input: memory.address, value: boolean)","p":["Attempts to write a boolean value.","Typically the size of a boolean is defined as 1 bit.","However some systems differ claiming 1 byte or 8 bits."]},{"l":"memory.write.char(input: memory.address, value: number)","p":["Attempts to write a char value.","Size: 1 Byte - 8 Bits"]},{"l":"memory.write.uchar(input: memory.address, value: number)","p":["Attempts to write a unsigned char value.","Size: 1 Byte - 8 Bits"]},{"l":"memory.write.short(input: memory.address, value: number)","p":["Attempts to write a short value.","Size: 2 Bytes - 16 Bits"]},{"l":"memory.write.ushort(input: memory.address, value: number)","p":["Attempts to write a unsigned short value.","Size: 2 Bytes - 16 Bits"]},{"l":"memory.write.int(input: memory.address, value: number)","p":["Attempts to write a int value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.write.uint(input: memory.address, value: number)","p":["Attempts to write a unsigned int value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.write.long(input: memory.address, value: number)","p":["Attempts to write a long value.","Size: 4 Bytes - 32 Bits (Win) | 8 Bytes - 64 Bits (Linux)"]},{"l":"memory.write.ulong(input: memory.address, value: number)","p":["Attempts to write a unsigned long value.","Size: 4 Bytes - 32 Bits (Win) | 8 Bytes - 64 Bits (Linux)"]},{"l":"memory.write.float(input: memory.address, value: number)","p":["Attempts to write a float value.","Size: 4 Bytes - 32 Bits"]},{"l":"memory.write.double(input: memory.address, value: number)","p":["Attempts to write a double value.","Size: 8 Bytes - 64 Bits"]},{"l":"memory.write.sequence(input: memory.address, value: number)","p":["Attempts to write a sequence of bytes to the address.","Example sequences that are valid: A1 B2 C3 or A1B2C3"]},{"l":"memory.write.address(input: memory.address, value: number)","p":["Attempts to write a address value."]},{"l":"memory.scan.bool(input: boolean, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain boolean value."]},{"l":"memory.scan.char(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain char value."]},{"l":"memory.scan.uchar(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain unsigned char value."]},{"l":"memory.scan.short(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain short value."]},{"l":"memory.scan.ushort(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain unsigned short value."]},{"l":"memory.scan.int(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain int value."]},{"l":"memory.scan.uint(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain unsigned int value."]},{"l":"memory.scan.long(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain long value."]},{"l":"memory.scan.ulong(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain unsigned long value."]},{"l":"memory.scan.float(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain float value."]},{"l":"memory.scan.double(input: number, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain double value."]},{"l":"memory.scan.address(input: memory.address, start?: memory.module | memory.region | memory.address, end?: memory.address): memory.address[]","p":["Attempts to scan for a certain void* value."]}],[{"l":"os","p":["This is an expansion to the existing Lua OS library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Format"},{"l":"Functions"},{"l":"os.clock(): number","p":["Returns the approximate amount of CPU time used by the current process in seconds."]},{"l":"os.date(format: string, time?: number): string","p":["Returns a string with the date and time formatted according to the format given. If no time is supplied defaults to the current time.","The format string can consist of \"* t\" on its own, or literal strings, mixed with other directives"]},{"l":"os.difftime(t1: number, t2: number): number","p":["Returns the number of seconds from time t1 to time t2.","In other words, the result is t1 - t2."]},{"l":"os.time(t?: number | table): number","p":["Returns the current time if no argument supplied.","The time is in seconds from the start of the current epoch.","On Windows, the function returns the number of seconds elapsed since midnight (00:00:00), January 1, 1970, coordinated universal time, according to the system clock."]},{"l":"Extension"},{"l":"os.argv.raw(): string","p":["Gets the raw commandline of the executable."]},{"l":"os.argv.flags(opt: string?): string[] | {[index: string]: boolean} | boolean","p":["Gets flag-like arguments from the commandline.","Flags are denoted as arguments with no values.","Passing a string will check to see if it exists."]},{"l":"os.argv.options(opt: string): string[] | {[index: string]: string} | string","p":["Gets option-like arguments from the commandline.","Options are denoted as arguments with values.","Passing a string will check to see if it exists and return its value."]},{"l":"os.argv.positional(): string[] | {[index: string]: boolean}","p":["Gets positional-like arguments from the commandline.","These are usually denote as having no \"-\", or \"--\" or \"+\" prefix, typically at the start."]},{"l":"os.argv.exists(opt: string): boolean, string?","p":["Checks for both flag-like and option-like arguments.","Useful if you just want to check if it \"exists\"."]}],[{"l":"reflection","p":["Responsible for lua-scripting execution and handling of API access cross-states. You can use this to also contact other lua_State instances, and create new ones. Do note you are responsible for spinning up new states.","Data transfer for these types are prohibited due to complications & safety:","Thread","Proto (this is being worked on)"]},{"l":"Threading","p":["As of currently, the thread isolation for lua_State is quite basic. As an example, if we create a new lua_State with thread isolation:","Nothing is perfect here, so do expect some problems with this system. Currently task.* only supports \"think\" operation, which runs every possible cycle. Do note that some cfunctions may not work depending on how they are implemented."]},{"l":"Functions"},{"l":"reflection.is(name: string): boolean","p":["Checks if the current execution is of a named lua_State"]},{"l":"reflection.get(name: string): lua_State?","p":["Attempts to locate a lua_State"]},{"l":"reflection.current(): lua_State","p":["Gets the current lua_State this is executed in"]},{"l":"reflection.all(): {[index: string]: lua_State}","p":["Gets all instances of lua_State and their names"]},{"l":"reflection.execute(source: string, name: string, state?: lua_State): string?","p":["Executes lua on a lua_State or the current active state its in"]},{"l":"reflection.compile(source: string, name: string): function | string","p":["Compiles lua on the the current active state its in"]},{"l":"reflection.open(name: string, threaded: boolean): lua_State","p":["Spawns a new lua_State instance or returns one if it already exists","By enabling threaded, will open the lua_State with its own runtime environment.","This can be accessed via task.* which is a signal specific for that state."]},{"l":"reflection.close(state: lua_State)","p":["Destroys a lua_State instance","This won't work on games with built-in lua_State instances"]},{"l":"reflection.stack(func: function(L: lua_State), state?: lua_State): any...","p":["Creates a stack isolated bridge to a lua_State.","Do note that you don't need to do this but using this reduces the risk of overflows."]},{"l":"Events","p":["Events that can be accessed under reflection.listener"]},{"l":"open(name: string, state: lua.state)","p":["Called when a lua_State has been created.","Do note that during the event, lua_State has not been fully initialized.","This can result in undefined behavior due to invalid objects, such as no _ G being available.","We recommend you defer a task before running anything."]},{"l":"close(name: string, state: lua.state)","p":["Called just before a lua_State is destroyed.","Typically managed by C itself on when a lua_State should be destroyed."]},{"l":"Lua State","p":["These are interface & function definitions for how we handle lua_State","This library can cause internal errors in Lua, likely causing a crash. We are working on isolating this better to prevent Lua itself from invoking exits."]},{"l":"L:execute(source: string, name: string): string?","p":["executes lua on a lua_State."]},{"l":"L:compile(source: string, name: string): string?","p":["Compiles lua on a lua_State.","Do note that doing this will push the function onto the stack, consider seeing more in CAPI."]},{"l":"L:stack(func: function(L: lua_State)): any?","p":["Creates a stack isolated bridge to a lua_State.","Do note that you don't need to do this but using this reduces the risk of overflows."]},{"l":"L:name(): string","p":["Converts a lua_State to its named counterpart"]},{"l":"L:threaded(): boolean","p":["Checks if the lua_State is running under a threaded environment"]},{"l":"L:internal(): boolean","p":["Checks if the lua_State is internally created","Internals prevent certain actions from being made, such as destruction"]},{"l":"L:root(): boolean","p":["Checks if the lua_State is a root of all other lua_State under it"]},{"l":"L:parent(): lua_State?","p":["Gets the parented lua_State"]},{"l":"L:children(): lua_State[]","p":["Gets all children associated with the lua_State"]},{"l":"L:api(): API","p":["Pushes the API onto the stack for access"]},{"l":"L:call(inputs: number, outputs: number)","p":["Calls a function thats pushed onto the stack","This will consume the no. inputs first, then execute the functions"]},{"l":"L:pop(count?: number)","p":["Pops a value off of the stack at the top"]},{"l":"L:remove(index: number)","p":["Removes a value at an index off of the stack"]},{"l":"L:length(index: number): number","p":["Used to get the length of a value"]},{"l":"L:next(index: number): boolean","p":["A pair-style iterator function for going through table"]},{"l":"L:pushany(value: any)","p":["Transfers any datatype from your environment to the stack"]},{"l":"L:getany(index: number): any","p":["Transfers any datatype from the stack to your environment"]},{"l":"L:gettop(): number","p":["Gets the current size of the Lua stack","This is useful for vararg style handling"]},{"l":"L:gettype(index: number): number","p":["Gets the type ID of a given value"]},{"l":"L:gettypename(index: number): string","p":["Gets the typename of a given value"]},{"l":"L:newtable()","p":["Generates a blank table and pushes it onto the stack"]},{"l":"L:newref(index: number): number","p":["Creates a reference link to a value","This will make the value immune to the garbage collector"]},{"l":"L:pushref(reference: number)","p":["Pushes the referenced value back onto the stack"]},{"l":"L:rmref(reference: number)","p":["Removes the referenced value from registry"]},{"l":"L:getupvalue(index: number, id: number): string","p":["Gets the \"upvalue\" of a function at the top of the stack","Upvalues are values passed to a function not as a parameter, but by reference"]},{"l":"L:setupvalue(index: number, id: number): string","p":["Sets the \"upvalue\" of a function at the top of the stack"]},{"l":"L:getfenv(index: number)","p":["Grabs the ENV and pushes it onto the stack","You can use this to manipulate the environment"]},{"l":"L:setfenv(index: number)","p":["Sets the ENV of a functions at the index","This consumes the table you provide it at the top of the stack","You can use this to manipulate the environment"]},{"l":"L:getmetatable(index: number): boolean","p":["Grabs the metatable of a table or userdata, and pushes it onto the stack","The boolean is provided for if it fails to grab the metatable"]},{"l":"L:setmetatable(index: number)","p":["Sets the metatable of a table or userdata at the index","This consumes the table you provide it at the top of the stack"]},{"l":"L:getfield(index: number, key: string)","p":["Gets the value from a table and pushes it onto the stack"]},{"l":"L:setfield(index: number, key: string)","p":["Sets a value in a table by key","Index corresponds to where the table is on the stack"]},{"l":"L:gettable(index: number)","p":["Gets the value from a table and pushes it onto the stack","This will consume a value just before it to determine the key"]},{"l":"L:settable(index: number)","p":["Sets a value in a table by the key at the top of the stack","The top of the stack is the key, and top-1 is the value"]},{"l":"L:rawget(index: number)","p":["Gets the value from a table and pushes it onto the stack","This will consume a value just before it to determine the key","Unlike gettable this will not invoke metatable callbacks"]},{"l":"L:rawset(index: number)","p":["Sets a value in a table by the key at the top of the stack","The top of the stack is the key, and top-1 is the value","Unlike settable this will not invoke metatable callbacks"]},{"l":"L:getboolean(index: number): boolean","p":["Attempts to get a boolean value from the Lua stack","If the type is invalid, an error will be thrown"]},{"l":"L:getnumber(index: number)","p":["Attempts to get a number value from the Lua stack","If the type is invalid, an error will be thrown"]},{"l":"L:getstring(index: number)","p":["Attempts to get a string value from the Lua stack","If the type is invalid, an error will be thrown"]},{"l":"L:pushboolean(value: boolean)","p":["Pushes a boolean onto the stack"]},{"l":"L:pushnil()","p":["Pushes a nil value onto the stack"]},{"l":"L:pushnumber(value: number)","p":["Pushes a number onto the stack"]},{"l":"L:pushstring(value: string)","p":["Pushes a string onto the stack"]},{"l":"L:pushfunction(value: function)","p":["Pushes a function onto the stack"]},{"l":"L:pushtable(value: table)","p":["Pushes a table onto the stack"]},{"l":"L:pushvalue(index: number)","p":["Makes a copy of a value at the index and pushes it to the top of the stack"]},{"l":"L:isboolean(index: number): boolean","p":["Checks if the value at index on the stack is a boolean"]},{"l":"L:iscfunction(index: number): boolean","p":["Checks if the value at index on the stack is a cfunction"]},{"l":"L:isfunction(index: number): boolean","p":["Checks if the value at index on the stack is a function"]},{"l":"L:islightuserdata(index: number): boolean","p":["Checks if the value at index on the stack is a lightuserdata"]},{"l":"L:isnil(index: number): boolean","p":["Checks if the value at index on the stack is nil"]},{"l":"L:isnumber(index: number): boolean","p":["Checks if the value at index on the stack is a number"]},{"l":"L:isstring(index: number): boolean","p":["Checks if the value at index on the stack is a string"]},{"l":"L:istable(index: number): boolean","p":["Checks if the value at index on the stack is a table"]},{"l":"L:isthread(index: number): boolean","p":["Checks if the value at index on the stack is a thread"]},{"l":"L:isuserdata(index: number): boolean","p":["Checks if the value at index on the stack is a userdata"]},{"l":"L:istype(index: number, type: number): boolean","p":["Checks if the value matches a specific type ID"]}],[{"l":"signal","p":["The Lua event handler for interstate & C++ calls. You can use this to contact other lua_State objects, make calls to C++, or have C++ make calls to you. Some libraries will have a Signal section to let you know of events they have, the functions here are for those libraries."]},{"l":"Lua Functions","p":["This is strictly for Lua based calls without a C++ counterpart. Supports interstate functionality, so that you can make calls to other lua_State threads."]},{"l":"signal.add(name: string, identity: string, callback: function)","p":["Adds a function to an signal, this will call the callback when C++ invokes it"]},{"l":"signal.remove(name: string, identity: string)","p":["Removes a function from a signal"]},{"l":"signal.get(name: string, identity: string): function?","p":["Attempts to retrieve a function from the signal callbacks"]},{"l":"signal.call(state: lua_State, name: string, ...any): ...any","p":["Calls events on a lua_State","Must have the same matching name for them to actually call"]},{"l":"signal.connect(name: string, callback: function, identity: string)","p":["Same as signal.add(name: string, identity: string, callback: function)","Different call style under the RBLX standard"]},{"l":"signal.disconnect(name: string, identity: string)","p":["Same as signal.remove(name: string, identity: string)","Different call style under the RBLX standard"]},{"l":"signal.connection(name: string, identity: string): function?","p":["Same as signal.get(name: string, identity: string): function?","Different call style under the RBLX standard"]},{"l":"signal.fire(state: lua_State, name: string, ...any): ...any","p":["Same as signal.call(state: lua_State, name: string, ...any): ...any","Different call style under the RBLX standard"]},{"l":"Library Functions","p":["These exists on libraries that have events or invokers, you can use these to talk to C++"]},{"i":"signaladdname-string-identity-string-callback-function-1","l":"signal.add(name: string, identity: string, callback: function)","p":["Adds a function to an signal, this will call the callback when C++ invokes it"]},{"i":"signalremovename-string-identity-string-1","l":"signal.remove(name: string, identity: string)","p":["Removes a function from a signal"]},{"i":"signalgetname-string-identity-string-function-1","l":"signal.get(name: string, identity: string): function?","p":["Attempts to retrieve a function from the signal callbacks","signal.call(name: string, ...any): ...any","Useful under conditions where C++ has multiple functions for a single purpose","Depends on the C++ developer's implementation"]},{"i":"signalconnectname-string-callback-function-identity-string-1","l":"signal.connect(name: string, callback: function, identity: string)","p":["Same as signal.add(name: string, identity: string, callback: function)","Different call style under the RBLX standard"]},{"i":"signaldisconnectname-string-identity-string-1","l":"signal.disconnect(name: string, identity: string)","p":["Same as signal.remove(name: string, identity: string)","Different call style under the RBLX standard"]},{"i":"signalconnectionname-string-identity-string-function-1","l":"signal.connection(name: string, identity: string): function?","p":["Same as signal.get(name: string, identity: string): function?","Different call style under the RBLX standard","signal.fire(name: string, ...any): ...any","Same as signal.call(name: string, ...any): ...any"]}],[{"l":"sodium","p":["The popular salt-based cryptographic library from libsodium. Specializing in cryptographic practices for security various types of data. All data created by this library is formatted in hexadecimal for memory safety.","Some sections here are being converted to use buffers instead of hex-string representations."]},{"l":"Functions"},{"l":"sodium.random(min: number, max: number, alpha?: boolean): string","p":["Creates a randomly generated string.","If alpha is true then strings will be alphabets rather than hexadecimal."]},{"l":"Hex","p":["Hexadecimal (or \"hex\") is a base-16 number system commonly used to represent binary data in a compact form."]},{"l":"sodium.hex.encode(input: string): string","p":["Converts data into it's hexadecimal form."]},{"l":"sodium.hex.decode(input: string): string","p":["Converts hexadecimal formatted data into it's original data."]},{"l":"Base64","p":["Base64 is a method of encoding binary data into an ASCII string using a fixed-size alphabet, which makes it easier to transmit or store the data over media that are designed to deal with textual data."]},{"l":"sodium.base64.encode(input: string): string","p":["Converts data into it's base64 form."]},{"l":"sodium.base64.decode(input: string): string","p":["Converts base64 formatted data into it's original data."]},{"l":"sodium.base64.xencode(input: string): string","p":["Converts hexadecimal formatted data into it's base64 form."]},{"l":"sodium.base64.xdecode(input: string): string","p":["Converts base64 formatted data into it's hexadecimal form."]},{"l":"HASH","p":["Cryptographic hash function that provides data integrity by creating a unique \"fingerprint\" of the input data. Not generally considered a cipher in the traditional sense, but rather a building block for various cryptographic protocols and algorithms."]},{"l":"sodium.hash.enc256(input: string): string","p":["Creates a SHA-256 block hash based on the input data."]},{"l":"sodium.hash.enc512(input: string): string","p":["Creates a SHA-512 block hash based on the input data."]},{"l":"HMAC","p":["HMAC (Hash-based Message Authentication Code) is a type of message authentication code that provides both authenticity and integrity by using a cryptographic hash function in combination with a secret key to produce a \"tag\" that verifies the message."]},{"l":"sodium.hmac.key256(): string","p":["Creates a HMAC-256 cipher key."]},{"l":"sodium.hmac.enc256(input: string, key: string): string","p":["Creates a HMAC-256 block hash based on the input data."]},{"l":"sodium.hmac.key512(): string","p":["Creates a HMAC-512 cipher key."]},{"l":"sodium.hmac.enc512(input: string, key: string): string","p":["Creates a HMAC-512 block hash based on the input data."]},{"l":"sodium.hmac.key512256(): string","p":["Creates a HMAC-512256 cipher key."]},{"l":"sodium.hmac.enc512256(input: string, key: string): string","p":["Creates a HMAC-512256 block hash based on the input data."]},{"l":"Signature","p":["Digital signatures are used to provide authenticity and integrity of a cipher message. They use public-key cryptography and a hash function to create a unique digital signature that can be used to verify the authenticity and integrity of the message."]},{"l":"sodium.signature.key(): string, string","p":["Creates a two-pair signature key.","Return in order of \"Public Key\" and \"Secret Key\"."]},{"l":"sodium.signature.encode(input: string, sk: string): string","p":["Encodes a message with the secret key."]},{"l":"sodium.signature.decode(input: string, pk: string): string","p":["Decodes a message with the public key."]},{"l":"AEAD","p":["Authenticated Encryption with Associated Data (AEAD) is a type of encryption algorithm that provides both confidentiality and authenticity for data."]},{"l":"ChaCha20Poly1305","p":["An authenticated encryption algorithm that uses the ChaCha stream cipher for encryption and the Poly1305 message authentication code."]},{"l":"sodium.aead.chachapoly.nonce(): string","p":["Generates a nonce which is used in securing uniqueness."]},{"l":"sodium.aead.chachapoly.key(base?: string, salt?: string): string","p":["Generates a key, providing a base acts as an offset, with providing a salt for greater resiliance."]},{"l":"sodium.aead.chachapoly.encrypt(input: string, key: string, nonce: string): string","p":["Encrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.chachapoly.decrypt(input: string, key: string, nonce: string): string","p":["Decrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.chachapoly.encode(input: string, key: string): string","p":["Encrypts a message based on the key, this generates its own nonce internally.","The nonce is applied to the start of the message."]},{"l":"sodium.aead.chachapoly.decode(input: string, key: string): string","p":["Decrypts a message based on the key, this handles its own nonce internally.","The nonce is applied to the start of the message."]},{"l":"GCM-256","p":["A block cipher mode of operation called Galois/Counter Mode (GCM) that provides both confidentiality and authenticity, using a 256-bit key."]},{"l":"sodium.aead.gcm.nonce(): string","p":["Generates a nonce which is used in securing uniqueness."]},{"l":"sodium.aead.gcm.key(base?: string, salt?: string): string","p":["Generates a key, providing a base acts as an offset, with providing a salt for greater resiliance."]},{"l":"sodium.aead.gcm.encrypt(input: string, key: string, nonce: string): string","p":["Encrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.gcm.decrypt(input: string, key: string, nonce: string): string","p":["Decrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.gcm.encode(input: string, key: string): string","p":["Encrypts a message based on the key, this generates its own nonce internally.","The nonce is applied to the start of the message."]},{"l":"sodium.aead.gcm.decode(input: string, key: string): string","p":["Decrypts a message based on the key, this handles its own nonce internally.","The nonce is applied to the start of the message."]},{"l":"AEGIS-256","p":["A new authenticated encryption algorithm that is designed to be fast and secure, using a 256-bit key. For applications these might not be standardized yet."]},{"l":"sodium.aead.aegis.nonce(): string","p":["Generates a nonce which is used in securing uniqueness."]},{"l":"sodium.aead.aegis.key(base?: string, salt?: string): string","p":["Generates a key, providing a base acts as an offset, with providing a salt for greater resiliance."]},{"l":"sodium.aead.aegis.encrypt(input: string, key: string, nonce: string): string","p":["Encrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.aegis.decrypt(input: string, key: string, nonce: string): string","p":["Decrypts a messages based on the key and added nonce."]},{"l":"sodium.aead.aegis.encode(input: string, key: string): string","p":["Encrypts a message based on the key, this generates its own nonce internally.","The nonce is applied to the start of the message."]},{"l":"sodium.aead.aegis.decode(input: string, key: string): string","p":["Decrypts a message based on the key, this handles its own nonce internally.","The nonce is applied to the start of the message."]}],[{"l":"string","p":["This is an expansion to the existing Lua String library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Format"},{"l":"Patterns"},{"l":"Sets"},{"l":"Repetition"},{"l":"Anchor"},{"l":"Special"},{"l":"Functions"},{"l":"string.byte(s: string, n?: number = 1): number","p":["Returns the ASCII code for the nth character of the string s. The inverse operation is carried out by string.char."]},{"l":"string.char(...: number): string","p":["Receives 0 or more numbers and converts them to the corresponding characters. The inverse operation is carried out by string.byte."]},{"l":"string.dump(f: function): string","p":["Converts a function f into binary representation, which can be subsequently processed by loadstring to retrieve the function.","The function must be a Lua function without upvalues."]},{"l":"string.find(str: string, pattern: string, index?: number = 1, plain?: boolean = false): number?, number?, ...?: string","p":["Find the first match of the regular expression \"pattern\" in \"str\", starting at position \"index\".","The starting position (index) is optional, and defaults to 1 (the start of the string).","If found, returns the start and end position, and any captures as additional results.","If \"plain\" is true, the search string is plain text, not a regular expression. (The \"plain\" argument is optional, and defaults to false)."]},{"l":"string.format(fstr: string, ...: any): string","p":["Formats the supplied values (v1, v2 etc.) using format string 'fstr', similar to the C function printf.","It is an error to supply too few variables for the format string.","The format string comprises literal text, and directives starting with %. Each directive controls the format of the next argument.","Directives can include flags, width and precision controls.","To literally incorporate % in the output you need to put %% in the format string."]},{"l":"string.gmatch(str: string, pattern: string): function","p":["Returns an iterator function for returning the next capture from a pattern over a string.","If there is no capture, the whole match is produced."]},{"l":"string.gsub(str: string, pattern: string, replacement: string | function | table, n?: number): string, number","p":["Returns a copy of str with matches to 'pattern' replaced by 'replacement', for a maximum of n times, as a second result it returns the number of matches made.","'replacement' can be a string in which case it simply replaces the matching pattern.","However %1 through to %9 in the replacement pattern can refer to captured strings in the source pattern. %% becomes %.","Also, %0 in the replacement pattern refers to the entire matching string.","If 'replacement' is a function it is called for each match with the matching string as an argument.","It should return a string which is the string to replace it with. If it returns nil the original string is retained.","If 'replacement' is a table then the matching string is looked up in the table for each match, and if found, the replacement is substituted."]},{"l":"string.len(str: string): number","p":["Returns the length of the string, including any imbedded zero (0x00) bytes."]},{"l":"string.lower(str: string): string","p":["Returns the string converted to lower-case."]},{"l":"string.match(str: string, pattern: string, index?: number): ...string","p":["Find the first match of the regular expression \"pattern\" in \"str\", starting at position \"index\".","The starting position (index) is optional, and defaults to 1 (the start of the string).","If found, returns any captures in the pattern. If no captures were specified the entire matching string is returned."]},{"l":"string.rep(str: string, n: number): string","p":["Returns a string which is n copies of the source string concatenated together."]},{"l":"string.reverse(str: string): string","p":["Returns a string that is the string str reversed."]},{"l":"string.sub(str: string, start: number, end?: number): string","p":["Returns a substring of the string, starting at index 'start' and ending at index 'end'. Both may be negative to indicate counting from the right. The end point is optional and defaults to -1, which is the entire rest of the string."]},{"l":"string.upper(str: string): string","p":["Returns the string converted to upper-case."]},{"l":"Extension"},{"l":"string.buffer(str: string): buffer","p":["Converts a string into a buffer."]}],[{"l":"table","p":["This is an expansion to the existing Lua Table library.","This is an expansion to builtins provided by Lua itself, see more about them on the official Lua/LuaJIT wikis."]},{"l":"Functions"},{"l":"table.concat(t: table, sep: string, start?: number, end?: number)","p":["Returns the (numeric) entries in the table t, concatenated together with \"sep\" as the separator, starting at index 'start' and ending at index 'end'.","The entries are returned as a single string variable.","Contrast this to the \"unpack\" function which returns a table as individual variables."]},{"l":"table.foreach(t: table, f: function(key: any, value: any))","p":["Executes f for each element in table t.","If f returns a non-nil value the loop is broken, and this value is returned as the result from table.foreach.","Effectively this could be used to find an element inside a table matching a certain condition."]},{"l":"table.foreachi(t: table, f: function(key: any, value: any))","p":["Similar to table.foreach, except that only numeric keys in the range 1 to n are processed."]},{"l":"table.getn(t: table): number","p":["Returns the size of a numerically-keyed table.","A table's size (which is only relevant for \"numeric\" indexed tables) is one less than the first integer index with a nil value.","If the table has \"holes\" in it - that is, numeric keys with gaps in the sequence - then the table size is not guaranteed to be the the last gap.","Lua does a binary search to try to find a gap, it does not necessarily find the first or last one."]},{"l":"table.insert(t: table, pos: number, value: any)","p":["Inserts the value at (optional) position 'pos', renumbering existing elements if necessary to make room. Thus the new element becomes the one with index 'pos'.","If called with 2 arguments, the value is inserted at n+1, that is, the end of the table."]},{"l":"table.maxn(t: table): number","p":["Returns the highest numeric key in the table, by examining each entry in the entire table.","This will necessarily be slower than doing table.getn, but would be needed if the keys have gaps in the sequence.","f the table does not have gaps in the keys, it is faster to use table.getn(t: table): number"]},{"l":"table.remove(t: table, pos?: number): any","p":["Removes the element at position 'pos' from the table, returning the value of the removed element.","If 'pos' is omitted it defaults to the end of the table (n), thus removing the last element."]},{"l":"table.sort(t: table, f?: function)","p":["Sorts the table using the supplied function f as the comparison function for each element.","Function f should return true if the first element is < the second element. If the function omitted it defaults to the operator <.","Sorting is not stable, that is, the sequence of equal keys is not necessarily preserved."]},{"l":"Extension"},{"l":"table.isarray(t: table): boolean","p":["Checks if a table is an array-like object."]},{"l":"table.tojson(t: table): string","p":["Attempts to convert a table to json format.","Some errors will be noted in brackets like [cyclic] indicating possible cyclic tables."]},{"l":"table.fromjson(v: string): table","p":["Attempts to convert a json format string into a table."]}],[{"l":"task","p":["Responsible for providing a continuous execution or calls. This is used for simply providing a \"runtime\" for lua states."]},{"l":"Functions"},{"l":"task.isthreaded(): boolean","p":["Checks if the current execution is from a threaded lua_State."]},{"l":"task.defer(f: function)","p":["Stores & calls the function at the next runtime cycle."]},{"l":"task.delay(t: number, f: function)","p":["Stores & calls the function after x amount of seconds.","This is also called in the runtime cycle."]},{"l":"task.add(name: string, identity: string, callback: function)","p":["Adds a function to the continuous runtime"]},{"l":"task.remove(name: string, identity: string)","p":["Removes a function from the continuous runtime"]},{"l":"task.get(name: string, identity: string): function?","p":["Attempts to retrieve a function from the continuous runtime's callbacks"]},{"l":"task.connect(callback: function, identity: string)","p":["Same as task.add(name: string, identity: string, callback: function)","Different call style under the RBLX standard"]},{"l":"task.disconnect(name: string, identity: string)","p":["Same as task.remove(name: string, identity: string)","Different call style under the RBLX standard"]},{"l":"task.connection(name: string, identity: string): function?","p":["Same as task.get(name: string, identity: string): function?","Different call style under the RBLX standard"]}]]